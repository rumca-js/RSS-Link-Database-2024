[{"vote": 0, "source_obj__id": 546, "bookmarked": false, "thumbnail": null, "dead": false, "comments": [], "artist": null, "page_rating_visits": 0, "page_rating_votes": 0, "tags": [], "user": null, "title": "Parsing Numbers At Compile Time with C++17, C++23, and C++26 -- Bartlomiej Filipek", "permanent": false, "age": null, "page_rating": 0, "description": "<p>\n\t<img alt=\"modern-parsingnum.png\" src=\"https://isocpp.org/files/img/modern-parsingnum.png\" style=\"width: 393px; margin: 10px; float: right;\" />Thanks to the powerful&nbsp;<code>constexpr</code>&nbsp;keyword and many enhancements in recent C++ standards, we can now perform a lot of computations at compile time. In this text, we&rsquo;ll explore several techniques for parsing integers, including the &ldquo;naive&rdquo; approach, C++23,<code>from_chars</code>,<code>std::optional</code>, <code>std::expected</code>, and even some upcoming features in C++26.</p>\n<blockquote>\n\t<h3>\n\t\t<a href=\"https://www.cppstories.com/2024/constexpr-number-parsing-cpp23/\">Parsing Numbers At Compile Time with C++17, C++23, and C++26</a></h3>\n\t<p>\n\t\tby Bartlomiej Filipek</p>\n</blockquote>\n<p>\n\tFrom the article:</p>\n<blockquote>\n\t<p id=\"why-at-compile-time\">\n\t\t<strong>Why at compile time?</strong></p>\n\t<p>\n\t\tWhile it may sound like a theoretical experiment, since C++11 we can shift more and more c", "date_published": "2024-02-28T19:42:31+00:00", "page_rating_contents": 0, "link": "https://isocpp.org//blog/2024/02/parsing-numbers-at-compile-time-with-cpp17-c23-and-c26-bartlomiej-filipek", "album": "", "source": "https://isocpp.org/blog/rss/category/news", "language": "en"}]