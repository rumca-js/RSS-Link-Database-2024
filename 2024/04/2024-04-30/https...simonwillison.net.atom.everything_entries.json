[{"age": null, "album": "", "artist": null, "bookmarked": false, "comments": [], "date_published": "2024-04-30T20:35:39+00:00", "description": "<blockquote cite=\"https://lmsys.org/blog/2024-03-01-policy/#our-policy\"><p>We collaborate with open-source and commercial model providers to bring their unreleased models to community for preview testing.<br /><br />Model providers can test their unreleased models anonymously, meaning the models&#x27; names will be anonymized. A model is considered unreleased if its weights are neither open, nor available via a public API or service.</p></blockquote><p class=\"cite\">&mdash; <a href=\"https://lmsys.org/blog/2024-03-01-policy/#our-policy\">LMSYS</a>", "language": "en-us", "link": "https://simonwillison.net/2024/Apr/30/lmsys/#atom-everything", "manual_status_code": 0, "page_rating": 32, "page_rating_contents": 100, "page_rating_visits": 0, "page_rating_votes": 0, "permanent": false, "source": "https://simonwillison.net/atom/everything", "source_obj__id": 423, "status_code": 0, "tags": [], "thumbnail": null, "title": "Quoting LMSYS", "user": null, "vote": 0}, {"age": null, "album": "", "artist": null, "bookmarked": false, "comments": [], "date_published": "2024-04-30T13:59:50+00:00", "description": "<blockquote cite=\"https://news.ycombinator.com/item?id=40206752#40209833\"><p>Performance analysis indicates that SQLite spends very little time doing bytecode decoding and dispatch. Most CPU cycles are consumed in walking B-Trees, doing value comparisons, and decoding records - all of which happens in compiled C code. Bytecode dispatch is using less than 3% of the total CPU time, according to my measurements.<br /><br />So at least in the case of SQLite, compiling all the way down to machine code might provide a performance boost 3% or less. That&#x27;s not very much, considering the size, complexity, and portability costs involved.</p></blockquote><p class=\"cite\">&mdash; <a href=\"https://news.ycombinator.com/item?id=40206752#40209833\">D. Richard Hipp</a>", "language": "en-us", "link": "https://simonwillison.net/2024/Apr/30/d-richard-hipp/#atom-everything", "manual_status_code": 0, "page_rating": 32, "page_rating_contents": 100, "page_rating_visits": 0, "page_rating_votes": 0, "permanent": false, "source": "https://simonwillison.net/atom/everything", "source_obj__id": 423, "status_code": 0, "tags": [], "thumbnail": null, "title": "Quoting D. Richard Hipp", "user": null, "vote": 0}, {"age": null, "album": "", "artist": null, "bookmarked": false, "comments": [], "date_published": "2024-04-30T11:19:21+00:00", "description": "<p><a href=\"https://medium.com/@maciej.pocwierz/how-an-empty-s3-bucket-can-make-your-aws-bill-explode-934a383cb8b1\">How an empty S3 bucket can make your AWS bill explode</a></p>\nMaciej Pocwierz accidentally created an S3 bucket with a name that was already used as a placeholder value in a widely used piece of software. They saw 100 million PUT requests to their new bucket in a single day, racking up a big bill since AWS charges $5/million PUTs.</p>\n<p>It turns out AWS charge that same amount for PUTs that result in a 403 authentication error, a policy <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html#ChargeDetails\">that extends</a> even to \"requester pays\" buckets!</p>\n<p>So, if you know someone's S3 bucket name you can DDoS their AWS bill just by flooding them with meaningless unauthenticated PUT requests.</p>\n<p>AWS support refunded Maciej's bill as an exception here, but I'd like to see them reconsider this broken policy entirely.\n\n    <p>Via ", "language": "en-us", "link": "https://simonwillison.net/2024/Apr/30/how-an-empty-s3-bucket-can-make-your-aws-bill-explode/#atom-everything", "manual_status_code": 0, "page_rating": 100, "page_rating_contents": 100, "page_rating_visits": 0, "page_rating_votes": 0, "permanent": false, "source": "https://simonwillison.net/atom/everything", "source_obj__id": 423, "status_code": 0, "tags": [], "thumbnail": null, "title": "How an empty S3 bucket can make your AWS bill explode", "user": null, "vote": 0}, {"age": null, "album": "", "artist": null, "bookmarked": false, "comments": [], "date_published": "2024-04-30T11:02:48+00:00", "description": "<p><a href=\"https://adactio.com/journal/21078\">My approach to HTML web components</a></p>\nSome neat patterns here from Jeremy Keith, who is using Web Components extensively for progressive enhancement of existing markup.</p>\n<blockquote>\n<p>The reactivity you get with full-on frameworks [like React and Vue] isn\u2019t something that web components offer. But I do think web components can replace jQuery and other approaches to scripting the DOM.</p>\n</blockquote>\n<p>Jeremy likes naming components with their element as a prefix (since all element names must contain at least one hyphen), and suggests building components under the single responsibility principle - so you can do things like <code>&lt;button-confirm&gt;&lt;button-clipboard&gt;&lt;button&gt;...</code>.</p>\n<p>Jeremy configure buttons with <code>data-</code> attributes and has them communicate with each other using custom events.</p>\n<p>Something I hadn't realized is that since the <code>connectedCallback</code> function on a cust", "language": "en-us", "link": "https://simonwillison.net/2024/Apr/30/approach-to-html-web-components/#atom-everything", "manual_status_code": 0, "page_rating": 100, "page_rating_contents": 100, "page_rating_visits": 0, "page_rating_votes": 0, "permanent": false, "source": "https://simonwillison.net/atom/everything", "source_obj__id": 423, "status_code": 0, "tags": [], "thumbnail": null, "title": "My approach to HTML web components", "user": null, "vote": 0}, {"age": null, "album": "", "artist": null, "bookmarked": false, "comments": [], "date_published": "2024-04-30T05:32:54+00:00", "description": "<p><a href=\"https://sqlite.org/draft/whybytecode.html\">Why SQLite Uses Bytecode</a></p>\nBrand new SQLite architecture documentation by D. Richard Hipp explaining the trade-offs between a bytecode based query plan and a tree of objects.</p>\n\n<p>SQLite uses the bytecode approach, which provides an important characteristic that SQLite can very easily execute queries incrementally\u2014stopping after each row, for example. This is more useful for a local library database than for a network server where the assumption is that the entire query will be executed before results are returned over the wire.\n\n    <p>Via <a href=\"https://twitter.com/DRichardHipp/status/1785037995101290772\">@DRichardHipp</a></p>", "language": "en-us", "link": "https://simonwillison.net/2024/Apr/30/why-sqlite-uses-bytecode/#atom-everything", "manual_status_code": 0, "page_rating": 100, "page_rating_contents": 100, "page_rating_visits": 0, "page_rating_votes": 0, "permanent": false, "source": "https://simonwillison.net/atom/everything", "source_obj__id": 423, "status_code": 0, "tags": [], "thumbnail": null, "title": "Why SQLite Uses Bytecode", "user": null, "vote": 0}]